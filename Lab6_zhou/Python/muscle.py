import numpy as np
from collections import namedtuple
import farms_pylog as pylog
import math


class Muscle(object):
    """This class implements the muscle model.
    The muscle model is based on the hill-type muscle model.
    """
    # Default Muscle Parameters
    c = np.log(0.05)  # pylint: disable=no-member
    n = 1.5
    k = 5.0
    tau_act = 0.01  # Time constant for the activation function
    e_ref = 0.04  # Reference strain
    w = 0.4  # Shaping factor

    #: Container for results
    Result = namedtuple('Result', "time activation l_ce l_mtu v_ce "
                        "active_force passive_force tendon_force")

    def __init__(self, name, parameters):
        """This function initializes the muscle model.
        A default muscle name is given as muscle

        Parameters
        ----------
        parameters : <MuscleParameters>
            Instance of MuscleParameters class

        Returns:
        -------
        Muscle : <Muscle>
            Returns an instance of class Muscle

        Attributes:
        ----------
        l_mtu : float
            Length of Muscle Tendon Complex
        l_slack : float
            Tendon slack length
        l_opt : float
            Optimal fiber length
        l_ce : float
            Length of contracticle element
        v_ce : float
            Velocity of contractile element
        active_force : float
            Active force generated by the muscle
        passive_force : float
            Passive force generated by the muscle
        force : float
            Sum of Active and Passive forces
        tendon_force : float
            Force generated by the muscle tendon
        stim : float
            Muscle stimulation.

        Methods:
        --------
        step : func
            Integrates muscle state by time step dt

        Example:
        --------
        >>> from SystemParameters import MuscleParameters
        >>> import Muscle
        >>> muscle_parameters = MuscleParameters()
        >>> muscle_1 = Muscle.Muscle(muscle_parameters)
        >>> muscle_1.stim = 0.01
        >>> muscle_1.step(dt)
        """

        self.name = name
        self.parameters = parameters

        # Internal variables
        self._l_ce = 0.0
        self._v_ce = 0.0

        # Muscle specific parameters initialization
        self.l_slack = parameters.l_slack
        self.l_opt = parameters.l_opt
        self.v_max = parameters.v_max
        self.f_max = parameters.f_max
        self.pennation = parameters.pennation

        # Muscle parameters initialization
        self._l_se = 0.0  # Muscle Series Element Length
        self._l_ce = 0.0  # Muscle Contracticle Element Length
        self._activation = 0.05  # Muscle activation
        self.stimulation = 0.05  # base stimulation
        self.l_mtu = 0.0  # Muscle Tendon Unit (MTU) length

        self.results = Muscle.Result(time=[], activation=[], l_ce=[],
                                     l_mtu=[], v_ce=[], active_force=[],
                                     passive_force=[], tendon_force=[])

    def compute_initial_l_ce(self, l_mtu):
        """This function initializes the muscle lengths."""
        if l_mtu < (self.l_slack + self.l_opt):
            l_ce = self.l_opt
        else:
            if (self.l_opt * Muscle.w + Muscle.e_ref * self.l_slack) != 0.0:
                _num = self.l_opt * Muscle.w + \
                    Muscle.e_ref * (l_mtu - self.l_opt)
                _den = self.l_opt * Muscle.w + Muscle.e_ref * self.l_slack
                l_se = self.l_slack*(_num/_den)
            else:
                l_se = self.l_slack
            l_ce = l_mtu - l_se
        return l_ce

    ######################### Attributes #########################

    @property
    def l_mtu(self):
        """ Length of Muscle Tendon Complex."""
        return self._l_mtu

    @l_mtu.setter
    def l_mtu(self, value):
        """ Set the length of muscle tendon complex. """
        self._l_mtu = value

    @property
    def l_ce(self):
        """ Length of muscle contracticle element."""
        return self._l_ce

    @property
    def active_force(self):
        """This function returns the active force generated by the muscle."""
        return self.compute_active_force(
            self.l_ce, self.v_ce, self._activation)

    @property
    def passive_force(self):
        """This function returns the passive force generated by the muscle."""
        return self._f_pe_star(self.l_ce) + self._f_be(self.l_ce)

    @property
    def v_ce(self):
        """Velocity of muscle contracticle element"""
        return self._v_ce

    @property
    def force(self):
        """Function returns the sum of active and passive force"""
        return self.active_force + self.passive_force

    @property
    def tendon_force(self):
        """This function returns the force generated by the muscle."""
        return self.compute_tendon_force(self.l_ce)

    ######################### Internal Methods #########################
    #: In standard python convention a method/attribute name starting
    #: starting with an underscore means that it is an internal attribute
    #: or method and the user should not use it unless they know what
    #: they are doing

    def _f_se(self, l_se):
        """This function computes the Force in the Series Element (SE).
        The function requires SE length l_SE as inputs."""
        f_se = (self.f_max * (
            (l_se - self.l_slack) / (
                self.l_slack * Muscle.e_ref))**2) * (
                    l_se > self.l_slack)
        return f_se

    def _f_pe_star(self, l_ce):
        """ This function computes the Force in the Parallel Element (PE).
        Force prevents the muscle from over-exentsion
        The function requires contracticle length l_ce as inputs."""
        if l_ce > self.l_opt:
            return self.f_max * (
                (l_ce - self.l_opt) / (self.l_opt * Muscle.w))**2
        return 0.0

    def _f_be(self, l_ce):
        """ This function computes the Force in the muscle belly.
        Force prevents the muscle from collapsing on itself.
        The function requires SE length l_SE as inputs."""
        if l_ce <= self.l_opt * (1.0 - Muscle.w):
            return (
                self.f_max * ((l_ce - self.l_opt * (1.0 - Muscle.w)) /
                              (self.l_opt * Muscle.w / 2.0))**2
            )
        return 0.0

    def _f_l(self, l_ce):
        """ This function computes the force from force-length relationship.
        The function requires SE length l_SE as inputs."""
        val = abs((l_ce - self.l_opt) / (self.l_opt * Muscle.w))
        exposant = Muscle.c * val * val * val
        return np.exp(exposant)

    def _f_v_ce(self, v_ce):
        """ This function computes the force from force-velocity relationship.
        The function requires contracticle velocity as inputs."""
        _v_max = self.v_max*self.l_opt
        if v_ce < 0.:
            return (_v_max - v_ce) / (
                _v_max + Muscle.k * v_ce)
        return Muscle.n + (Muscle.n - 1) * (
            _v_max + v_ce) / (7.56 * Muscle.k * v_ce - _v_max)

    def _f_v(self, f_se, f_be, act, f_l, f_pe_star):
        """ This function computes the force from force-velocity relationship.
        The function requires
        f_se : Series element force
        f_be : Muscle belly force
        act : muscle activation
        f_l : Force from force-length relationship
        f_pe_star : Parallel element force."""
        if math.isclose(
            self.f_max * act * f_l + f_pe_star, 0.0, abs_tol=1e-6
        ):
            f_v = 0.0
        else:
            f_v = (f_se + f_be) / ((self.f_max * act * f_l) + f_pe_star)

        f_v = 1.5 if f_v > 1.5 else f_v
        f_v = 0.0 if f_v < 0.0 else f_v

        return f_v

    def _v_ce_inv(self, f_v):
        """ This function computes the Contracticle element velocity.
        The function requires force from force-velocity relationship."""
        _v_max = self.v_max*self.l_opt
        if f_v < 1.0:
            return _v_max * (1.0 - f_v) / (1.0 + f_v * Muscle.k)
        else:
            return (
                _v_max * (f_v - 1.0) / (
                    7.56 * Muscle.k * (f_v - Muscle.n) + 1.0 - Muscle.n
                )
            )

    ######################### ODE #########################

    def activation_dadt(self, stimulation, activation):
        """This function updates the activation function of the muscle.
        The function requires time step dt as the inputs"""
        #: Check the bounds of the stimulation
        stimulation = max(0.05, min(1.0, stimulation))
        da_dt = (stimulation - activation) / Muscle.tau_act

        return da_dt

    def dxdt(self, state, time, *args):
        """ Function returns the derivative of muscle activation and
        length of the contracticle element

        Parameters:
        -----------
            - state : Muscle states
                - state[0] : <float>
                  A : Muscle activation
                - state[1] : <float>
                  l_CE : length of contracticle element

        Returns:
        --------
            - dA : Dynamics of the muscle activation
            - velocity : Muscle state derivative (
                         velocity of contracticle element)
        """
        self.stimulation = args[0]
        self.l_mtu = args[1]

        activation = state[0]
        l_ce = state[1] if state[1] > 0.0 else 0.0
        l_se = self.l_mtu - l_ce

        v_ce = self._v_ce_inv(
            self._f_v(
                self._f_se(l_se),
                self._f_be(l_ce),
                activation,
                self._f_l(l_ce),
                self._f_pe_star(l_ce)
            )
        )
        return np.asarray(
            [[self.activation_dadt(self.stimulation, activation)],
             [v_ce]]
        )[:, 0]

    ######################### METHODS FOR LOGGING #########################

    def compute_active_force(self, l_ce, v_ce, act):
        """This function computes the Active Muscle Force.
        The function requires
        l_ce : Contracticle element length
        v_ce : Contracticle element velocity
        a : muscle activation."""
        return act * self._f_v_ce(v_ce) * self._f_l(l_ce) * self.f_max

    def compute_passive_force(self, l_ce):
        """ This computes the passive force generated by the muscle."""
        return self._f_pe_star(l_ce) + self._f_be(l_ce)

    def compute_tendon_force(self, l_se):
        """This function computes the muscle tendon force.
        The function requires contracticle element length"""
        return self._f_se(l_se)

    def instantiate_result_from_state(self, time):
        """ Instatiate the result container. """
        self.Result = Muscle.Result(
            time=np.zeros(np.shape(time)),
            activation=np.zeros(np.shape(time)),
            l_ce=np.zeros(np.shape(time)),
            l_mtu=np.zeros(np.shape(time)),
            v_ce=np.zeros(np.shape(time)),
            active_force=np.zeros(np.shape(time)),
            passive_force=np.zeros(np.shape(time)),
            tendon_force=np.zeros(np.shape(time))
        )

    def generate_result_from_state(self, idx, time, l_mtu, state):
        """ Generate the results from the muscle states. """
        #: Clear up old results
        l_ce = state[1]
        l_se = l_mtu - l_ce
        activation = state[0]
        f_v = self._f_v(
            self._f_se(l_se),
            self._f_be(l_ce),
            activation,
            self._f_l(l_ce),
            self._f_pe_star(l_ce))
        v_ce = self._v_ce_inv(f_v)

        self.Result.time[idx] = time
        self.Result.l_mtu[idx] = l_mtu
        self.Result.activation[idx] = activation
        self.Result.l_ce[idx] = l_ce
        self.Result.v_ce[idx] = v_ce
        self.Result.active_force[idx] = self.compute_active_force(
            l_ce, v_ce, activation
        )
        self.Result.passive_force[idx] = self.compute_passive_force(l_ce)
        self.Result.tendon_force[idx] = self.compute_tendon_force(l_se)

